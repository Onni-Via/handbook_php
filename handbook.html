<!DOCTYPE HTML>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <title></title>
</head>
<body>
<h1>Конспект уроков</h1>
<h2>Урок 0. Файл, память, командная строка</h2>
<h3>Память</h3>
Внешняя память — это память которая способна хранить информацию, причем хранить ее неогранно долго. Постоянаая память сохраняет свои значения между сессиями работы компьютера. Энергонезависимая память. Память с нелинейный доступом (произвольным).

Оперативная память — хранит свои значения пока ПК включен. Энергозависемая память. Память с нелинейный доступом (произвольным).

Буферная память — активна когда диск четает данные быстрее чем ПК их принимает. Т.е в буфере диск накаплифает данные пока ПК их принимает.
Буфер — блок памяти произвольного доступа, который используется для временного хранения ввода или вывода.

<h3>О файлах</h3>
Файл — это совокупность информации+заголовка+служебная информация (напр. размер, расширение) который описывает информацию.

Расширение — это просто часть имени файла (3 байта). В линуксе нет понятия расширение.

Адресация — назначение адреса/сектора на диске.

Сatalog/корень (File Allocation Table(FAT) - таблица размещения файлов) - список файлов на диске (принцип зависит от файловой системы).
Может ссылатся на файлы, директории.

Директория (папка) — это специального вида ФАЙЛ, который содержит в себе список других файлов. Каждая директория может ссылать как на файлы, так и на другую директорию.

Путь до файла — указание для файловой системы, где файл искать.

Вложенность = дерево (принятая в информатике концепция).

Длина строки по умолчанию, желательно 80 символов (считается что такое кол-во человек видет целиком).

<h3>Низкоуровневые комманды для работы с файловой системой</h3>
pwd - узнать где я нахожусь

ls - список файлов в той директории где я нахожусь (синем цветом выделяет дирректории, зеленым файлы которые можно запустить (exe))
Примеры:
ls -l покажет файлы с подробной информацией

cd(в том числе точка(текущая папка) и две точки(перейти выше, выше это к корню)) - сменить текущую дирректорию
Примеры:
cd / -смена на корень
cd ./01 - переход в папку котора я находится в текущей папке

mkdir - создает новую дирректорию внутри текущей дирректории
Примеры:
mkdir 01
mkdir .02 - тоже самое, но указание явное

rmdir - удаление папки
Примеры:
rmdir ./03

touch - создает файл
Примеры:
touch text.txt

cat - вывести содержимое файла (быстро посмотреть что внутри)

cp - копиравание файлов

rm - удаление файла

df - просмотр объема дискового пространства

vim - вход в редактор vim, это редактор коммандный
Примеры:
vim ./text.txt
esc:q!enter - выход из vim

Дополнительные комманды замисываются через минус(-)

<h2>Урок 1. Выражения, переменные, типы</h2>
<h3>О сервере и php</h3>
Исполнение программ на php — программы исполняются на сервере.
php предназначен для создания бизнесс логики веб приложения.

Клиент-серверная архитектура — клиент отправляет на сервер запрос, сервер получает запрос и отправляет клиенту ответ. 
Клиент(браузер) и сервер это две программы.

Результат работы программы на php — это текст(байты), который передается клиенту(браузеру) в ответ на его запрос. Результат выводится в поток вывода.
Примеры:
2+2<?php echo 2+2;?> где php управляющая конструкция

<h3>О выражениях и значениях</h3>
Выражение — это некое значение, заданное или в явном виде («литерал») или в виде некоего вычисления (последовательности операций).
Выражение — это то, что можно вычеслить.
Примеры:
2 // это число
1.5 // это тоже число, но нецелое
'foo' // это строка из 3 символов
2 + 2 // это выражение, его результат = 4
2 * 2 // 2 и 2 это операнды, * это оператор, а результат это произведение

Выражение всегда имеет значение (то, чему оно равно)
<h3>Операции</h3>
• Арифметические ( + - * / )
• Сравнения ( == != < > )
• Логические ( && || ! )
• Строковые
• и др.

Присваивание — результат операции присваиваниея это то, что было присвоено.
Пример:
($x = 42) == 42;

<h3>О переменной</h3>
Переменная — это имя для какого то значения.
Переменная – это некое значение (выражение), сохраненное под понятным для нас именем.
В PHP объявление переменной (создание имени) и присваивание ей значения – это одна операция.
Пример:
$a; - значение null
$age = 42;
$result = 2 + 2 * 2;

<h3>О типах</h3>
int, integer - целые числа.
float - дробные числа.
Пример:
var_dump(floar((0.1+0.7)*10)); - где floar округление дроби в меньшую сторону, тип при этом не меняется.
string - строки
boolean (bool) Логическое значение, или «истина» (true) или ложь (false). Ответ на какой либо вопрос или результат сравнения.
Примеры:
$a = true;
$b = false;
$x = (2 == 2);
$y = ($x != $a);
(bool)0 - выдаст false
(bool)5 - все кроме 0 выдаст true
(bool)'' и искл. (bool)'0' - false
(bool)'не пустая строка' - true
Приведение к boolean (casting):
• (bool)0 == false; (bool)'' == false
Обратно:
• (int)false == 0; (string)false == '';
• (int)true == 1; (string)true == '1';

Строка — это последовательность/набор символов(байт).
str_replace('первый арг. что заменить', 'на что', 'где')

<h3>Приведение преобразования типов</h3>  
Тип значения приводится к наиболее подходящему, чтобы соответствовать типу оператора.
Тип результата операции всегда определяется оператором.
Например:
арифметические операции всегда производят числа.
оператор «точка» (сложение строк) всегда производит строки.

Неявное преобразование (приведение, каст) типов - строку с числом
Явное преобразование типов - указывать тип (int)'42'

<h2>Урок 2. Функции, оператора контроля. Включение файлов</h2>

<h3>Логические операторы</h3>
Пример  Название    Результат
$a and $b   И   true, если и $a, и $b true.
$a or $b    Или true, если или $a, или $b true.
$a xor $b   Исключающее или true, если $a, или $b true, но не оба.
! $a    Отрицание   true, если $a не true.
$a && $b    И   true, если и $a, и $b true.
$a || $b    Или true, если или $a, или $b true.

<h3>Условные конструкции</h3>
ВЕТВЛЕНИЕ – это оператор PHP, определяющий, должен ли выполняться тот или иной код в зависимости от чего-либо.
Пример:
if ($x > $y) {
$m = $x;
} else {
$m = $y;
}
Рекомендация: при сравнении переменной и типа(строки и тд). Справа указать переменную слева тип, поможет от опечаток (равенство, вместо присвоения).

Форма с перебором:
$color = 'green';
if($color == 'red') {
    echo 'Красный';
} elseif('$color == 'green'') {
    echo 'Зеленый';
} elseif('$color == 'blue'') {
    echo 'Синий';   
} else {
    echo 'Другой';
}
Альтернатива:
switch ($color) {
    case red:
        echo 'Красный';
        break;
    case green:
        echo 'Зеленый';
        break;
    case blue:
        echo 'Синий'; 
        break;
    default:
        echo 'Другой';
    break;
}

Еще одна альтернатива:
switch (true) {
    case red:
        echo 'Красный';
        break;
    case $color == 'green':
        echo 'Зеленый';
        break;
    case blue:
        echo 'Синий'; 
        break;
    default:
        echo 'Другой';
    break;
}
break прерывает перебор условий, не забывайте писать этот оператор!
Секция default выполнится, если не совпало ни одно сравнение, ее может и не быть.
Несколько case могут быть записаны один за другим и отвечать за один и тот же случай.

<h3>О функции</h3>
ФУНКЦИЯ – это подпрограмма, имеющая имя, набор входных значений (аргументов) и возвращаемое значение (необязательно и не использовать echo).
Функция — определяется, вызывается принимает аргументы и возвращает значение.
Функция — это некий кусок программы, которому можно дать имя и по имени вызвать.
Пример:
function maxnum($a, $b) {
    if ($a > $b) {
        return $a;
    } else {
        return $b;
    }
}
$m = maxnum(3, 5);
echo maxnum(-1, 1);

Имя функции должно быть уникальным и не совпадать с именем библиотечной функции
return – это оператор возврата значения из функции. Их может быть несколько или не быть вообще. Оператор прерывает выполнение функции!
Все переменные, объявленные в функции, будут локальными и перестанут существовать после выхода из нее
Глобальные переменные недоступны в функции

<h3>О константе</h3>
КОНСТАНТА – это значение, которое однажды создается и больше изменяться не может.
Константы задаются с помощью ключевого слова const и, в отличие от переменных, не имеют знака $.
Пример:
const PI = 3.14159;
const SEC_IN_DAY = 86400;
const HOST = 'localhost';

Имена констант принято записывать большими буквами
Значением константы может быть число, строка, логическое значение – то, что не требует вычисления

<h3>О подключении файлов</h3>
АРХИТЕКТУРНО ВЕРНО разделять свою программу на отдельные файлы.
В один файл функции, а в другие файлы тот код, который их использует.
include __DIR__ . '/functions.php'; // include берет файл functions.php' компилирует его и подключает
__DIR__ – это «магическая» константа. Она всегда содержит в себе полный путь в ФС до папки с текущим файлом
include подключает файл, в случае его недоступности – выведет предупреждение, но продолжит работу программы
require подключает файл, но в случае его недоступности вызовет фатальную ошибку и завершит программу
include_once и require_once не будут подключать указанный файл, если он уже ранее был подключен

<h3>О тестах</h3>
МОДУЛЬНЫЙ ТЕСТ – это код, содержащий утверждения о том, как должны работать отдельные модули (части) программы
В PHP принято использовать модульные тесты для того, чтобы доказать, что ваша программа работает верно, и чтобы отслеживать ошибки при изменении кода.
Пример:
function maxnumber($a, $b) {
...
}
assert( 1 == maxnumber(1,1) );
assert( 1 == maxnumber(-1,1) );
assert( 1 == maxnumber(1,-1) );

Старайтесь писать тесты до написания кода
Установите настройки:
display_errors On
error_reporting E_ALL
zend.assertions = 1
<h2>Урок 3. Массивы, циклы, взаимодействие с пользователем</h2>
<h3>О принцепе ленивых вычислений</h3>
Принцип ленивых вычислений:
function a(){
    echo 'a'
    return true;
}
function b(){
    echo 'b'
    return true;
}

$result = a() || b(); вызов функии a или b, вернет первый вызов, так как программе результат очевиден, дальше вызов и вычисление не идет.

<h3>О массивах</h3>
Массив — это последовательность значений, которое хранится как одно целое. 
Состоит из элементов, каждый элемент это пара (ключ(индекс)ключем может быть число или строка, но только уникальные) и значение (значением может быть что угодно).
Массивы динамические, элемент можно добавить или убрать.

Массив в PHP может содержать в себе любое количество элементов любого типа.
Пример:
$foo = [1, 13, 'bar', 'baz', 42];

В массив можно в любой момент добавить еще один элемент.
Пример:
$foo = [1, 2, 3];
$foo[] = 5;

Можно обратится по ключу и получить значение.
Примере:
$months = [
    'январь' => 31,
    'февраль' => 28,
    'март' => 31
];

echo $months['январь']; // получили значение (узнали сколько дней в январе)

<h4>О многомерных массивах</h4>
Многомерные массивы — массив в качестве одного из своих элементов может иметь другой массив.
Вложенность массивов друг в друга неограничена.
Для обращения к элементам многомерного массива используются несколько квадратных скобок.
Пример:
$arr = [
1 => [10, 20, 30],
2 => [100, 200, 300]
];
$arr[1]; // это массив [10, 20, 30]
$arr[1][0]; // это число 10

<h4>Перебор массива (цикл foreach)</h4>
foreach (имя массива as переменная для присвоения значения) {
    1. Берет массив по имени
    2. Берет первый элемент
    3. Значение элемента присвоит переменной
    4. Выполнет код в фигур. скобках
    5. Повторит пока не пройдет весь массив
}
Пример:
foreach ($months as $days) {
    echo $days;
    echo '___';
}
Выведем Ключ = значение ;
foreach ($months as $key => $days) {
    echo $key;
    echo '=';  
    echo $days;
    echo ';';
}

<h4>Функции для работы с массивами</h4>
in_array($value, $array); Проверяет, содержится ли в массиве $array элемент со значением $value, возвращает true либо false
Пример:
in_array(31, $months); // что ищу, где ищу - вернет логический тип

isset($array[$x]); Проверяет, содержится ли в массиве $array элемент с индексом $x, возвращает true либо false
Пример:
if(isset($months['январь'])){
    echo 'Есть январь?';
}

Есть ли в массиве $months элемент у которого индекс равен значению переменной $m и если есть, сообщу что он есть:
$m = 'апрель';
if(isset($months[$m])){
    echo 'Есть' . $m;
}
array_merge($arr1, $arr2) Возвращает объединение массивов, то есть массив, состоящий из всех элементов и первого, и второго

array_intersect($arr1, $arr2) Возвращает пересечение массивов, то есть массив, состоящий из тех элементов, что есть и в первом, и во втором

$array = explode(',', $string); Разбивает строку на «кусочки», используя указанный разделитель, возвращает массив

$string = implode(',', $array); «Склеивает» массив в строку, собирая эту строку из элементов массива, используя указанный разделитель. Функция принимает разделитель и массив, возвращая строку.

unset($months[январь]); Убирает элемент массива по индексу.

<h3>Взаимодействие с клиентом (GET и POST)</h3>
Метод GET протокола HTTP
Самый простой метод для передачи данных от клиента к серверу
• Берем ссылку (URL) http://php1.ru/index.php
• Дописываем после пути знак вопроса и пару «ключ-значение» через знак «=» http://php1.ru/index.php?foo=bar
• Имя параметра: foo
• Значение параметра: bar
• Переходим по ссылке – параметры передались на сервер. На сервере они доступны нам сразу и везде в суперглобальном массиве $_GET
• Можно передать несколько параметров, разделяя их знаком «&»: http://php1.ru/index.php?p1=foo&p2=42

Пример:
$months = [
    1 => 31,
    2 => 28,
    3 => 31,
];

$num = $_GET['ключ в адресе'];
echo $months[$num];
или
echo $months[$_GET['ключ в адресе']];

Метод POST протокола HTTP
В отличие от GET:
• Данные идут «невидимо» для пользователя (но мы их можем посмотреть в отладчике)
• Данных может быть много
• Они шифруются, если передаются по HTTPS
Как начать использовать?
• Для начала вам нужно подготовить форму:
<form action="/send.php" method="post">
<input type="text" name="login">
<input type="password" name="pass">
<button type="submit">Войти</button>
</form>
• Обратите внимание на атрибуты action и method
• Каждый элементы формы должен иметь имя (атрибут name)
• Данные из формы будут доступны в суперглобальном массиве $_POST

<h2>Урок 4. Работа с файлами на сервере. Загрузка от клиента.</h2>
<h3>О циклах while и do while</h3>
Цикл – WHILE («пока»)
while (условие) { тело цикла }
цикл будет выполняться,
ПОКА условие - ИСТИНА
Пример:
$i = 1;
while ($i <= 10) {
echo $i;
$i++; // $i = $i + 1;
}

Возможна (но редко применяется) и обратная форма записи:
$i = 0;
do {
echo $i;
$i++;
} while ($i <= 10)
Разница в том, что цикл с пост-условием всегда выполнится хотя бы один раз

<h3>О чтении файлов</h3>
Тип ресурс - это соединение с чем-то (файл, база данных и тд.)

ЧТЕНИЕ файлов – способы прочитать данные из файла в свою программу
Открыть файл. При этом мы получим «ресурс» – ссылку на открытый файл, с которой потом сможем работать:
$res = fopen(ПУТЬКФАЙЛУ, 'r');

Затем в цикле читать строки из файла:
while ( !feof($res) ) {
$line = fgets($res, 1024)
}

Закрыть файл:
fclose($res);


$fh = fopen(__DIR__ . 'файл', 'режим')

Выводим строки файла, пока не дойдем до пустой строки.
do {
    $str = fgets($fh);
    echo $str;
} while (false !== $str);

fclose($fh);

Альтернатива: пока не достигнут конец файла -читай выводи
while (!feof($fh)) {
    $str = fgets($fh);
    echo $str;
} 
fclose($fh);

<h4>Функции чтения</h4>
• fopen(путь к файлу, режим работы с файлом)
• fclose(закрытие соеденения с файлом)
• fread()
• fgets()
fgets - берем очередную строку
feof - достигнут ли конец файла
file(ПУТЬКФАЙЛУ); - возвращает массив из всех строк файла
file_get_contents(ПУТЬКФАЙЛУ); Чтение целиком файла в строку. Самый оптимальный по производительности вариант. Помещает содержимое файла в одно значения типа стринг, в одну переменную, если надо работать с ним как с одной строкой - функция считывает файл в память
readfile() - берет файл целиком его читает и сразу выкидывает его в поток вывода, отправляет клиенту- читает файл сразу в буфер,мало памяти занимает
file_exists() проверяет что файл вообще существует
is_readable() проверяет что файл доступен для чения

<h3>О записи файлов</h3>
ЗАПИСЬ в файл – способы из программы записать данные в файл
Способ первый:
$res = fopen(ПУТЬКФАЙЛУ, 'w');
fwrite($res, $data); // string!
fclose($res);
Режимах открытия файлов:
• r – чтение
• r+ - чтение и запись
• w – запись. файл будет создан, если не существовал или «обнулен»
• w+ – запись и чтение. файл будет создан, если не существовал или «обнулен»
• a – запись. файл будет создан, если не существовал. запись в конец файла

$fh = fopen(__DIR__ . 'файл', 'режим');
fwrite($fh, 'что записываем');
fclose($fh);

Способ второй:
file_put_contents(ПУТЬКФАЙЛУ, что в него записать);

// foo.php
$res = 2 + 2;
return $res;
// index.php
$foo = include(__DIR__ . '/foo.php');
echo $foo;
Файлы в PHP, как и функции, могут возвращать значения с помощью оператора return.
Чтобы это значение получить – достаточно получить то, что вернет конструкция include

<h3>Средства для работы не только с отдельными файлами, но с файловой системой в целом</h3>
Например, следующие функции:
• scandir($path)
Возвращает массив имён всех файлов, содержащихся в папке $path
• dirname($path)
Имя родительской папки для указанного файла (или папки)
• pathinfo($path)
Возвращает массив с частями пути (путь, имя файла, расширение)
filesize($path)
Размер файла $path в байтах
• realpath($path)
Возвращает канонический абсолютный путь для указанного. Раскрывает все «.», «..», ссылки и так далее

is_dir - проверяет дериктория ли это
is_file - проверяет файл ли это
is_link - проверяет ссылка ли это

Пример:
$list = scandir(__DIR__);
foreach($list as $file) {
    if(is_dir($file)) {
        echo 'Папка';
    } elseif (is_file($file)) {
        echo 'Файл: ';
    }
echo $file;

<h3>Загрузка файлов</h3>
Форма загрузки:
<form action="/upload.php" method="post" enctype="multipart/form-data">
<input type="file" name="myimg">
<button type="submit">Отправить</button></form>
}

Для того, чтобы иметь возможность загрузить файлы от клиента (из браузера) на сервер, нужно:
Прочитать данные из суперглобального массива $_FILES (в нем находятся файлы переданные от клиента, хранит во временном месте на сервере):
if ( isset($_FILES['myimg']) ) {
    if (0 == $_FILES['myimg']['error']) {
    $res = move_uploaded_file($_FILES['myimg']['tmp_name'], ПОЛНЫЙПУТЬНОВОЕИМЯНАСЕРВЕРЕ);
    }
}
Где: 1. Проверяем что данные пришли 2. Файл передан без ошибок 3. Переместили файл в постоянное место хранения.
</body>
</html>