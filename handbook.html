<!DOCTYPE HTML>
<html>
<head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <title></title>
    <style type="text/css">
    body {
        width: 70%;
        height: auto;
    }    
    h1 {
    font-family: Arial,  sans-serif;    
    }
    h2 {
    font-family: Arial,  sans-serif;    
    }
    h3 {
    font-family: Arial,  sans-serif;    
    } 
    h4 {
    font-family: Arial,  sans-serif;    
    }      
    p {
    font-family: Verdana,  sans-serif;
    font-size: 16px;
    }
    code {
    font-family: Arial,  sans-serif;
    font-size: 14px;
    color: #ba3c3c;
    }
    ul {
    font-family: Verdana,  sans-serif;
    font-size: 16px;
    }
    ol {
    font-family: Verdana,  sans-serif;
    font-size: 16px;
    }
    table {
    font-family: Verdana,  sans-serif;
    font-size: 16px;
    }

    </style>
</head>
<body leftmargin="100">
<h1>Конспект уроков</h1>
</br>
<h2>Урок 0. Файл, память, командная строка</h2>
</br>
<h3>Память</h3>
<p><strong>Внешняя память</strong> — это память которая способна хранить информацию, причем хранить ее неограниченно долго. Постоянная память сохраняет свои значения между сессиями работы компьютера. Энергонезависимая память. Память с нелинейным доступом (произвольным).</p>
<p><strong>Оперативная память</strong> — хранит свои значения пока ПК включен. Энергозависимая память. Память с нелинейным доступом (произвольным).</p>
<p><strong>Буферная память</strong> — активна, когда диск читает данные быстрее чем ПК их принимает. Т.е в буфере диск накапливает данные пока ПК их принимает.</p>
<p><strong>Буфер</strong> — блок памяти произвольного доступа, который используется для временного хранения ввода или вывода.</p>
</br>
<h3>О файлах</h3>
<p><strong>Файл</strong> — это совокупность информации + заголовка + служебная информация (напр. размер, расширение) который описывает информацию.</p>
<p><strong>Расширение</strong> — это просто часть имени файла (3 байта). В линуксе нет понятия расширение.</p>
<p><strong>Адресация</strong> — назначение адреса/сектора на диске.</p>
<p><strong>Сatalog/корень (File Allocation Table(FAT)</strong> - таблица размещения файлов) - список файлов на диске (принцип зависит от файловой системы).
Может ссылаться на файлы, директории.</p>
<p><strong>Директория (папка)</strong> — это специального вида <strong>файл</strong>, который содержит в себе список других файлов. Каждая директория может ссылать как на файлы, так и на другую директорию.</p>
<p><strong>Путь до файла</strong> — указание для файловой системы, где файл искать.</p>
<p><strong>Вложенность</strong> = дерево (принятая в информатике концепция).</p>
<p>Длина строки по умолчанию, желательно <strong>80 символов</strong> (считается что такое кол-во человек видит целиком).</p>
</br>

<h3>Низкоуровневые команды для работы с файловой системой</h3>
<p><strong>pwd</strong> - узнать где я нахожусь</p>
<p><strong>ls</strong> - список файлов в той директории где я нахожусь (синем цветом выделяет директории, зеленым файлы которые можно запустить (exe))</p>
<p>Примеры:</p>
<code>
ls -l // покажет файлы с подробной информацией</br>
</code>
<p><strong>cd</strong> (в том числе точка(текущая папка) и две точки(перейти выше, выше это к корню)) - сменить текущую директорию</p>
<p>Примеры:</p>
<code>
cd / // смена на корень</br>
cd ./01 // переход в папку которая находится в текущей папке</br>
</code>
<p><strong>mkdir</strong> - создает новую директорию внутри текущей директории</p>
<p>Примеры:</p>
<code>
mkdir 01</br>
mkdir ./02 // тоже самое, но указание явное</br>
</code>
<p><strong>rmdir</strong> - удаление папки</p>
<p>Примеры:</p>
<code>
rmdir ./03</br>
</code>
<p><strong>touch</strong> - создает файл</br>
<p>Примеры:</p>
<code>
touch text.txt</br>
</code>
<p><strong>cat</strong> - вывести содержимое файла (быстро посмотреть, что внутри)</p>
<p><strong>cp</strong> - копирование файлов</p>
<p><strong>rm</strong> - удаление файла</p>
<p><strong>df</strong> - просмотр объема дискового пространства</p>
<p><strong>vim</strong> - вход в редактор vim, это редактор командный</p>
<p>Примеры:</p>
<code>
vim ./text.txt</br>
</code>
<p>esc:q!enter - выход из vim без сохранения (esc:q - сохранение)</p>
<p>Дополнительные команды записываются через минус (-)</p>
</br>

<h2>Урок 1. Выражения, переменные, типы</h2>
<h3>О сервере и php</h3>
<p><strong>Исполнение программ на php</strong> — программы исполняются на сервере.</p>
<p>php предназначен для создания бизнес логики веб приложения.</p>
<p><strong>Клиент-серверная архитектура</strong> — клиент отправляет на сервер запрос, сервер получает запрос и отправляет клиенту ответ. Клиент(браузер) и сервер это две программы.</p>
<p><strong>Результат работы программы на php — это текст(байты)</strong>, который передается клиенту(браузеру) в ответ на его запрос. Результат выводится в поток вывода.</p>
<p>Примеры:</p>
<code>
2+2<?php echo 2+2;?> // где php управляющая конструкция</br>
</code>
</br>

<h3>О выражениях и значениях</h3>
<p><strong>Выражение</strong> — это некое значение, заданное или в явном виде («литерал») или в виде некоего вычисления (последовательности операций).</p>
<p>Выражение — это то, что можно вычислить.</p>
<p>Примеры:</p>
<code>
2 // это число</br>
1.5 // это тоже число, но нецелое</br>
'foo' // это строка из 3 символов</br>
2 + 2 // это выражение, его результат = 4</br>
2 * 2 // 2 и 2 это операнды, * это оператор, а результат — это произведение</br>
</code>
<p>Выражение всегда имеет значение (то, чему оно равно)</p>
</br>

<h3>Операции</h3>
<ul>
<li>Арифметические ( + - * / )</li>
<li>Сравнения ( == != < > )</li>
<li>Логические ( && || ! )</li>
<li>Строковые</li>
<li>и др.</li>
</ul>
<p><strong>Присваивание</strong> — результат операции присваиваниея это то, что было присвоено.</p>
<p>Пример:</p>
<code>
($x = 42) == 42;</br>
</code>
</br>

<h3>О переменной</h3>
<p><strong>Переменная</strong> — это имя для какого-то значения.</p>
<p><strong>Переменная</strong> — это некое значение (выражение), сохраненное под понятным для нас именем.</p>
<p><strong>В PHP объявление переменной</strong> (создание имени) и присваивание ей значения – это одна операция.</p>
<p>Пример:</p>
<code>
$a; - значение null</br>
$age = 42;</br>
$result = 2 + 2 * 2;</br>
</code>
</br>

<h3>О типах</h3>
<p><strong>int, integer</strong> - целые числа.</p>
<p><strong>float</strong> - дробные числа.</p>
<p>Пример:</p>
<code>
var_dump(floar((0.1+0.7)*10)); - где floar округление дроби в меньшую сторону, тип при этом не меняется.</br>
</code>
<p><strong>string</strong> - строки</p>
<p><strong>boolean (bool)</strong> Логическое значение, или «истина» (true) или ложь (false). Ответ на какой либо вопрос или результат сравнения.</p>
<p>Примеры:</p>
<code>
$a = true;</br>
$b = false;</br>
$x = (2 == 2);</br>
$y = ($x != $a);</br>
(bool)0 - выдаст false</br>
(bool)5 - все кроме 0 выдаст true</br>
(bool)'' и искл. (bool)'0' - false</br>
(bool)'не пустая строка' - true</br>
</code>
<p>Приведение к boolean (casting):</p>
<code>
(bool)0 == false; (bool)'' == false</br>
</code>
<p>Обратно:</p>
<code>
(int)false == 0; (string)false == '';</br>
(int)true == 1; (string)true == '1';</br>
</code>
<p><strong>Строка</strong> — это последовательность/набор символов(байт).</p>
<p>str_replace('первый арг. что заменить', 'на что', 'где')</p>
</br>

<h3>Приведение преобразования типов</h3>  
<p><strong>Тип значения приводится</strong> к наиболее подходящему, чтобы соответствовать типу оператора.</p>
<p>Тип <strong>результата операции</strong> всегда определяется оператором.</p>
<p>Например:</p>
<ul>
<li>арифметические операции всегда производят числа.</li>
<li>оператор «точка» (сложение строк) всегда производит строки.</li>
</ul>
<p><strong>Неявное преобразование</strong> (приведение, каст) типов - строку с числом</p>
<p><strong>Явное преобразование</strong> типов - указывать тип (int)'42'</p>
</br>

<h2>Урок 2. Функции, оператора контроля. Включение файлов</h2>
</br>
<h3>Логические операторы</h3>
<table border="1">
    <tr>
        <td>Пример</td>
        <td>Название</td>
        <td>Результат</td>
    </tr>
    <tr>
        <td>$a and $b</td>
        <td>и</td>
        <td>true, если и $a, и $b true.</td>
    </tr>
    <tr>
        <td>$a or $b</td>
        <td>или</td>
        <td>true, если или $a, или $b true.</td>
    </tr>
    <tr>
        <td>$a xor $b</td>
        <td>исключающее или</td>
        <td>true, если $a, или $b true, но не оба.</td>
    </tr>
    <tr>
        <td>! $a</td>
        <td>отрицание</td>
        <td>true, если $a не true.</td>
    </tr>
    <tr>
        <td>$a &amp;&amp; $b</td>
        <td>и</td>
        <td>true, если и $a, и $b true.</td>
    </tr>
    <tr>
        <td>$a || $b</td>
        <td>или</td>
        <td>true, если или $a, или $b true.</td>
    </tr>
</table>
</br>

<h3>Условные конструкции</h3>
<p><strong>ВЕТВЛЕНИЕ</strong> – это оператор PHP, определяющий, должен ли выполняться тот или иной код в зависимости от чего-либо.</p>
<p>Пример:</p>
<code>
if ($x > $y) { </br>
$m = $x; </br>
} else { </br>
$m = $y; </br>
} </br>
</code>
<p><strong>Рекомендация:</strong> при сравнении переменной и типа (строки и тд). Справа указать переменную слева тип, поможет от опечаток (равенство, вместо присвоения).</p>
<p>Форма с перебором:</p>
<code>
$color = 'green'; </br>
if($color == 'red') { </br>
    echo 'Красный'; </br>
} elseif('$color == 'green'') { </br>
    echo 'Зеленый'; </br>
} elseif('$color == 'blue'') { </br>
    echo 'Синий'; </br>   
} else { </br>
    echo 'Другой'; </br>
} </br>
</code>
<p>Альтернатива:</p>
<code>
switch ($color) {</br>
    case red:</br>
        echo 'Красный';</br>
        break;</br>
    case green:</br>
        echo 'Зеленый';</br>
        break;</br>
    case blue:</br>
        echo 'Синий';</br>
        break;</br>
    default:</br>
        echo 'Другой';</br>
    break;</br>
}</br>
</code>
<p>Еще одна альтернатива:</p>
<code>
switch (true) {</br>
    case red:</br>
        echo 'Красный';</br>
        break;</br>
    case $color == 'green':</br>
        echo 'Зеленый';</br>
        break;</br>
    case blue:</br>
        echo 'Синий';</br>
        break;</br>
    default:</br>
        echo 'Другой';</br>
    break;</br>
}</br>
</code>
<p>break прерывает перебор условий, не забывайте писать этот оператор!</p>
<p>Секция <strong>default</strong> выполнится, если не совпало ни одно сравнение, ее может и не быть.</p>
<p>Несколько case могут быть записаны один за другим и отвечать за один и тот же случай.</p>
</br>

<h3>О функции</h3>
<p><strong>Функция</strong> – это подпрограмма, имеющая имя, набор входных значений (аргументов) и возвращаемое значение (необязательно и не использовать echo).</p>
<p>Функция — определяется, вызывается принимает аргументы и возвращает значение.</p>
<p>Функция — это некий кусок программы, которому можно дать имя и по имени вызвать.</p>
<p>Пример:</p>
<code>
function maxnum($a, $b) {</br>
    if ($a > $b) {</br>
        return $a;</br>
    } else {</br>
        return $b;</br>
    }</br>
}</br>
$m = maxnum(3, 5);</br>
echo maxnum(-1, 1);</br>
</code>
<p>Имя функции должно быть уникальным и не совпадать с именем библиотечной функции</p>
<p>return – это оператор возврата значения из функции. Их может быть несколько или не быть вообще. Оператор прерывает выполнение функции!</p>
<p>Все переменные, объявленные в функции, будут локальными и перестанут существовать после выхода из нее</p>
<p><strong>Глобальные переменные недоступны</strong> в функции</p>
</br>

<h3>О константе</h3>
<p><strong>Константа</strong> – это значение, которое однажды создается и больше изменяться не может.</p>
<p>Константы задаются с помощью ключевого слова const и, в отличие от переменных, не имеют знака $.</p>
<p>Пример:</p>
<code>
const PI = 3.14159;</br>
const SEC_IN_DAY = 86400;</br>
const HOST = 'localhost';</br>
</code>
<p>Имена констант принято записывать большими буквами.</p>
<p>Значением константы может быть число, строка, логическое значение – то, что не требует вычисления</p>
</br>

<h3>О подключении файлов</h3>
<p><strong>Архитектурно верно</strong> разделять свою программу на отдельные файлы.</p>
<p>В один файл функции, а в другие файлы тот код, который их использует.</p>
<p>include __DIR__ . '/functions.php'; // include берет файл functions.php' компилирует его и подключает</p>
<p><strong>__DIR__</strong> – это «магическая» константа. Она всегда содержит в себе полный путь в ФС до папки с текущим файлом</p>
<p><strong>include</strong> подключает файл, в случае его недоступности – выведет предупреждение, но продолжит работу программы</p>
<p><strong>require</strong> подключает файл, но в случае его недоступности вызовет фатальную ошибку и завершит программу</p>
<p><strong>include_once</strong> и require_once не будут подключать указанный файл, если он уже ранее был подключен</p>
</br>

<h3>О тестах</h3>
<p><strong>Модульный тест</strong> – это код, содержащий утверждения о том, как должны работать отдельные модули (части) программы</p>
<p>В PHP принято использовать модульные тесты для того, чтобы доказать, что ваша программа работает верно, и чтобы отслеживать ошибки при изменении кода.</p>
<p>Пример:</p>
<code>
function maxnumber($a, $b) {</br>
...</br>
}</br>
assert( 1 == maxnumber(1,1) );</br>
assert( 1 == maxnumber(-1,1) );</br>
assert( 1 == maxnumber(1,-1) );</br>
</code>
<p>Старайтесь писать тесты до написания кода</p>
<p>Установите настройки:</p>
<code>
display_errors On</br>
error_reporting E_ALL</br>
zend.assertions = 1</br>
</code>
</br>

<h2>Урок 3. Массивы, циклы, взаимодействие с пользователем</h2>
<h3>О принцепе ленивых вычислений</h3>
<p>Принцип ленивых вычислений:</p>
<code>
function a(){</br>
    echo 'a'</br>
    return true;</br>
}</br>
function b(){</br>
    echo 'b'</br>
    return true;</br>
}</br>
$result = a() || b(); // вызов функии a или b, вернет первый вызов, так как программе результат очевиден, дальше вызов и вычисление не идет.</br>
</code>
</br>

<h3>О массивах</h3>
<p><strong>Массив</strong> — это последовательность значений, которое хранится как одно целое.</p> 
<p>Состоит из элементов, каждый элемент это пара (ключ(индекс)ключем может быть число или строка, но только уникальные) и значение (значением может быть что угодно).</p>
<p>Массивы динамические, элемент можно добавить или убрать.</p>
<p>Массив в PHP может содержать в себе любое количество элементов любого типа.</p>
<p>Пример:</p>
<code>
$foo = [1, 13, 'bar', 'baz', 42];</br>
</code>
<p>В массив можно в любой момент добавить еще один элемент.</p>
<p>Пример:</p>
<code>
$foo = [1, 2, 3];</br>
$foo[] = 5;</br>
</code>
<p>Можно обратится по ключу и получить значение.</p>
<p>Примере:</p>
<code>
$months = [</br>
    'январь' => 31,</br>
    'февраль' => 28,</br>
    'март' => 31</br>
];</br>
echo $months['январь']; // получили значение (узнали сколько дней в январе)</br>
</code>
</br>

<h4>О многомерных массивах</h4>
<p><strong>Многомерные массивы</strong> — массив в качестве одного из своих элементов может иметь другой массив.</p>
<p>Вложенность массивов друг в друга неограничена.</p>
<p>Для обращения к элементам многомерного массива используются несколько квадратных скобок.</p>
<p>Пример:</p>
<code>
$arr = [</br>
1 => [10, 20, 30],</br>
2 => [100, 200, 300]</br>
];</br>
$arr[1]; // это массив [10, 20, 30]</br>
$arr[1][0]; // это число 10</br>
</code>
<h4>Перебор массива (цикл foreach)</h4>
<code>
foreach (имя массива as переменная для присвоения значения) {</br>
...</br>
}</br>
</code>
<ol>
<li>Берет массив по имени</li>
<li>Берет первый элемент</li>
<li>Значение элемента присвоит переменной</li>
<li>Выполнет код в фигур. скобках</li>
<li>Повторит пока не пройдет весь массив</li>
</ol>
<p>Пример:</p>
<code>
foreach ($months as $days) {</br>
    echo $days;</br>
    echo '___';</br>
}</br>
</code>
<p>Выведем Ключ = значение;</p>
<code>
foreach ($months as $key => $days) {</br>
    echo $key;</br>
    echo '=';</br>  
    echo $days;</br>
    echo ';';</br>
}</br>
</code>
<h4>Функции для работы с массивами</h4>
<p><strong>in_array($value, $array);</strong> Проверяет, содержится ли в массиве $array элемент со значением $value, возвращает true либо false</p>
<p>Пример:</p>
<code>
<p>in_array(31, $months); // что ищу, где ищу - вернет логический тип</p>
</code>
<p><strong>isset($array[$x]);</strong> Проверяет, содержится ли в массиве $array элемент с индексом $x, возвращает true либо false</p>
<p>Пример:</p>
<code>
if(isset($months['январь'])){</br>
    echo 'Есть январь?';</br>
}</br>
</code>
<p>Есть ли в массиве $months элемент у которого индекс равен значению переменной $m и если есть, сообщу что он есть:</p>
<code>
$m = 'апрель';</br>
if(isset($months[$m])){</br>
    echo 'Есть' . $m;</br>
}
</code>
<p><strong>array_merge($arr1, $arr2)</strong> Возвращает объединение массивов, то есть массив, состоящий из всех элементов и первого, и второго.</p>
<p><strong>array_intersect($arr1, $arr2)</strong> Возвращает пересечение массивов, то есть массив, состоящий из тех элементов, что есть и в первом, и во втором</p>
<p><strong>$array = explode(',', $string);</strong> Разбивает строку на «кусочки», используя указанный разделитель, возвращает массив.</p>
<p><strong>$string = implode(',', $array);</strong> «Склеивает» массив в строку, собирая эту строку из элементов массива, используя указанный разделитель. Функция принимает разделитель и массив, возвращая строку.</p>
<p><strong>unset($months[январь]);</strong> Убирает элемент массива по индексу.</p>
</br>

<h3>Взаимодействие с клиентом (GET и POST)</h3>
<p>Метод GET протокола HTTP</p>
<p>Самый простой метод для передачи данных от клиента к серверу:</p>
<ul>
<li>Берем ссылку (URL) http://php1.ru/index.php</li>
<li>Дописываем после пути знак вопроса и пару «ключ-значение» через знак «=» http://php1.ru/index.php?foo=bar</li>
<li>Имя параметра: foo</li>
<li>Значение параметра: bar</li>
<li>Переходим по ссылке – параметры передались на сервер. На сервере они доступны нам сразу и везде в суперглобальном массиве $_GET</li>
<li>Можно передать несколько параметров, разделяя их знаком «&»: http://php1.ru/index.php?p1=foo&p2=42</li>
</ul>
<p>Пример:</p>
<code>
$months = [</br>
    1 => 31,</br>
    2 => 28,</br>
    3 => 31,</br>
];</br>
$num = $_GET['ключ в адресе'];</br>
echo $months[$num];</br>
или
echo $months[$_GET['ключ в адресе']];</br>
</code>
<p>Метод POST протокола HTTP</p>
<p>В отличие от GET:</p>
<ul>
<li>Данные идут «невидимо» для пользователя (но мы их можем посмотреть в отладчике)</li>
<li>Данных может быть много</li>
<li>Они шифруются, если передаются по HTTPS</li>
</ul>
<p>Как начать использовать? Нужно подготовить форму:</p>
<form action="/send.php" method="post">
<input type="text" name="login">
<input type="password" name="pass">
<button type="submit">Войти</button>
</form>
<p>Обратите внимание на атрибуты action и method</p>
<p>Каждый элементы формы должен иметь имя (атрибут name)</p>
<p>Данные из формы будут доступны в суперглобальном массиве $_POST</p>
</br>

<h2>Урок 4. Работа с файлами на сервере. Загрузка от клиента.</h2>
<h3>О циклах while и do while</h3>
<p>Цикл – WHILE («пока»):</p>
<ul>
<li>while (условие) { тело цикла }</li>
<li>цикл будет выполняться,</li>
<li>ПОКА условие - ИСТИНА</li>
</ul>
<p>Пример:</p>
<code>
$i = 1;</br>
while ($i <= 10) {</br>
echo $i;</br>
$i++; // $i = $i + 1;</br>
}</br>
</code>
<p>Возможна (но редко применяется) и обратная форма записи:</p>
<code>
$i = 0;</br>
do {</br>
echo $i;</br>
$i++;</br>
} while ($i <= 10)</br>
</code>
<p>Разница в том, что цикл с пост-условием всегда выполнится хотя бы один раз</p>
</br>

<h3>О чтении файлов</h3>
<p><strong>Тип ресурс</strong> - это соединение с чем-то (файл, база данных и тд.)</p>
<p><strong>Чтение файлов</strong> – способы прочитать данные из файла в свою программу</p>
<p>Открыть файл. При этом мы получим «ресурс» – ссылку на открытый файл, с которой потом сможем работать:</p>
<p>$fh = fopen(__DIR__ . 'файл', 'режим')</p>
<p>$res = fopen(ПУТЬКФАЙЛУ, 'r');</p>
<p>Затем в цикле читать строки из файла:</p>
<code>
while ( !feof($res) ) {</br>
$line = fgets($res, 1024)</br>
}</br>
</code>
<p>Закрыть файл:</p>
<code>
fclose($res);</br>
</code>
<p>Выводим строки файла, пока не дойдем до пустой строки.</p>
<code>
do {</br>
    $str = fgets($fh);</br>
    echo $str;</br>
} while (false !== $str);</br>
fclose($fh);</br>
</code>
<p>Альтернатива: пока не достигнут конец файла -читай выводи</p>
<code>
while (!feof($fh)) {</br>
    $str = fgets($fh);</br>
    echo $str;</br>
}</br>
fclose($fh);</br>
</code>
</br>

<h4>Функции чтения</h4>
<p><strong>fopen(путь к файлу, режим работы с файлом)</strong></p>
<p><strong>fclose(закрытие соеденения с файлом)</strong></p>
<p><strong>fread()</strong></p>
<p><strong>fgets()</strong></p>
<p><strong>fgets</strong> - берем очередную строку</p>
<p><strong>feof</strong> - достигнут ли конец файла</p>
<p><strong>file(ПУТЬКФАЙЛУ);</strong> - возвращает массив из всех строк файла</p>
<p><strong>file_get_contents(ПУТЬКФАЙЛУ);</strong> Чтение целиком файла в строку. Самый оптимальный по производительности вариант. Помещает содержимое файла в одно значения типа стринг, в одну переменную, если надо работать с ним как с одной строкой - функция считывает файл в память.</p>
<p><strong>readfile()</strong> — берет файл целиком его читает и сразу выкидывает его в поток вывода, отправляет клиенту- читает файл сразу в буфер,мало памяти занимает.</p>
<p><strong>file_exists()</strong> — проверяет что файл вообще существует.</p>
<p><strong>is_readable()</strong> — проверяет что файл доступен для чения.</p>
</br>
<h3>О записи файлов</h3>
<p>Запись в файл – способы из программы записать данные в файл</p>
<p>Способ первый:</p>
<code>
$res = fopen(ПУТЬКФАЙЛУ, 'w');</br>
fwrite($res, $data); // string!</br>
fclose($res);</br>
</code>
<p>Режимах открытия файлов:</p>
<ul>
<li>r – чтение</li>
<li>r+ - чтение и запись</li>
<li>w – запись. файл будет создан, если не существовал или «обнулен»</li>
<li>w+ – запись и чтение. файл будет создан, если не существовал или «обнулен»</li>
<li>a – запись. файл будет создан, если не существовал. запись в конец файла</li>
</ul>
<code>
$fh = fopen(__DIR__ . 'файл', 'режим');</br>
fwrite($fh, 'что записываем');</br>
fclose($fh);</br>
</code>
<p>Способ второй:</p>
<code>
file_put_contents(ПУТЬКФАЙЛУ, что в него записать);</br>
</code>
<p>Пример:</p>
<p>// foo.php</p>
<code>
$res = 2 + 2;</br>
return $res;</br>
</code>
<p>// index.php</p>
<code>
$foo = include(__DIR__ . '/foo.php');</br>
echo $foo;</br>
</code>
<p>Файлы в PHP, как и функции, могут возвращать значения с помощью оператора return.</p>
<p>Чтобы это значение получить – достаточно получить то, что вернет конструкция include</p>
</br>
<h3>Средства для работы не только с отдельными файлами, но с файловой системой в целом</h3>
<p>Например, следующие функции:</p>
<p><strong>scandir($path)</strong> — Возвращает массив имён всех файлов, содержащихся в папке $path</p>
<p><strong>dirname($path)</strong> — Имя родительской папки для указанного файла (или папки)</p>
<p><strong>pathinfo($path)</strong> — Возвращает массив с частями пути (путь, имя файла, расширение)</p>
<p><strong>filesize($path)</strong> — Размер файла $path в байтах</p>
<p><strong>realpath($path)</strong> — Возвращает канонический абсолютный путь для указанного. Раскрывает все «.», «..», ссылки и так далее</p>
<p><strong>is_dir</strong> — проверяет дериктория ли это</p>
<p><strong>is_file</strong> — проверяет файл ли это</p>
<p><strong>is_link</strong> — проверяет ссылка ли это</p>
<p>Пример:</p>
<code>
$list = scandir(__DIR__);</br>
foreach($list as $file) {</br>
    if(is_dir($file)) {</br>
        echo 'Папка';</br>
    } elseif (is_file($file)) {</br>
        echo 'Файл: ';</br>
    }</br>
echo $file;</br>
</code>
</br>
<h3>Загрузка файлов</h3>
<p>Форма загрузки:</p>
<form action="/upload.php" method="post" enctype="multipart/form-data">
<input type="file" name="myimg">
<button type="submit">Отправить</button></form>
<p>Для того, чтобы иметь возможность загрузить файлы от клиента (из браузера) на сервер, нужно:</p>
<p>Прочитать данные из суперглобального массива $_FILES (в нем находятся файлы переданные от клиента, хранит во временном месте на сервере):</p>
<code>
if ( isset($_FILES['myimg']) ) {</br>
    if (0 == $_FILES['myimg']['error']) {</br>
    $res = move_uploaded_file($_FILES['myimg']['tmp_name'], ПОЛНЫЙПУТЬНОВОЕИМЯНАСЕРВЕРЕ);</br>
    }</br>
}</br>
</code>
<p>Где: 1. Проверяем что данные пришли 2. Файл передан без ошибок 3. Переместили файл в постоянное место хранения.</p>
</br>

<h2>Git start</h2>
<p>Рекомендация: книга PRO Git (Git для профессионального программиста изд питер - перевод версия)</p>
<p><strong>Git</strong> — система контроля версий (набор консольных команд) позволяет:</p>
<ul>
<li>управлять историей изменений, ведет полную историю версий в папке (репозиторий)</li>
<li>работать совместно</li>
<li>Git не отслеживает пустую папку.</li>
</ul>
<p><strong>Ветка</strong> (измение, состояние) это альтернативная история изменений. Ветка это просто перемещаемая метка для коммита. Ветки связаны между собой как родитель и потомок</p>
<p><strong>Ветвление</strong> — у одного коммита несколько следующих коммитов</p>
</br>

<h3>Git на ОС</h3>
<p>Linux — apt-get install git</p>
<p>Windows — git-for-windows.github.io</p>
</br>

<h3>Команды в Bash</h3>
<p><strong>git</strong> - проверка что git установлен</p>
<p><strong>git config</strong> (меняем кофигурацию) --global (в целом на ПК) user.name "Меняем имя"</p>
<p><strong>git init</strong> - создать репозиторий</p>
<p><strong>git status</strong> - показывает состояние репозитория, где:</p>
<ul>
<li>initial commit - инициализировали репозиторий и не фиксировали другие изменения</li>
<li>nothing to commit - нечего фиксировать</li>
<li>untracked files - файлы судьбу которых git не отслеживает</li>
<li>modified - изменившийся файл, ранее добавили под контроль git после чего его изменили не подготовив</li>
<li>unmodified - файл git видет, но они ни как не поменялись</li>
<li>staged - подготовка к фиксации файла в том состоянии в котором он есть</li>
</ul>
<p><strong>git add</strong> - затрекать файл, чтобы git за ним следил (по умолчанию не следит пока не сказано)</p>
<p><strong>git commit -m "комментарий"</strong> - создание точки в истоии, фиксация изменений(состояния)</p>
<p><strong>git commit –a –m "комментарий"</strong> - git add и git commit в одну команду</p>
<p><strong>git log</strong> - список изменений</p>
<p><strong>git log -p</strong> - покажет разницу между комитами (q-выход из режима просмотра)</p>
<p><strong>git log --stat</strong> - просмотр статистики по коммитам</p>
<p><strong>git log --all --graph</strong> - выведет все коммиты с графиком</p>
<p><strong>git rm File</strong> - удаляет как файл так и инфу о нем из git</p>
<p><strong>git rm --cached File</strong> - удаяет файл из индекса git (забывает файл)</p>
<p><strong>git commit --amend</strong> -добавит изменения к последнему коммиту (на случай если мы мелочи забыли внести)</p>
<p><strong>git reset --hard номер коммита</strong> - переход на другой коммит</p>
<p><strong>git branch name</strong> - создание новой ветки (ветка по умолчанию master, здесть указать другое имя)</p>
<p><strong>git checkout name</strong> - переключение на ветку</p>
<p><strong>git merge name</strong> - я на ветке a и прошу слить в нее ветку b</p>
<ul>
<li>github: создать новый репризиторий -> выбрать настройки приватности -> нажать readme -> принять</li>
<li>git clone ссылка на репризиторий github</li>
<li>ls -l - позволит проверить что README.MD на месте</li>
<li>git remote -v - просмотр связей github</li>
<li>git posh - передаст коммиты с ПК на github</li>
<li>git pull -получить изменения с github себе</li>
</ul>
<p><strong>git flow</strong> - методика работы с ветками</p>
<p>Набор расширений git предоставляющий высокоуровневые операции над репозиторием для поддержки модели ветвления.</p>
<p>Для каждой задачи создается своя ветка, название начинается на feature/* git flow feature start MYFEATURE</p>
<p>Ветки публикуются на удаленном сервере, чтобы ваши коллеги имели к ним доступ git flow feature publish MYFEATURE</p>
<p>При завершении работы над задачей нужно «закрыть» ветку – она вольется в ветку develop git flow feature finish MYFEATURE</p>
<p>Когда вы решили достаточное число задач – откройте и опубликуйте релиз</p>
<p>git flow release start MYRELEASE</p>
<p>git flow release publish MYRELEASE</p>
<p>Завершите релиз – и он вольется в ветку master git flow release finish MYRELEASE</p>
<p>nano - редактор, альтернатива vim</p>
</br>

<h2>Cookie, сессии, авторизация</h2>
<p><strong>Запрос и ответ</strong> — это просто текст (байты).</p>
<p>Пример(тестируем Cookies):</p>
<code>
<?php header('Set-Cookie: foo=52'); // размещать нужно всегда первым, до вывовода информации в index?>
</code>
<p>Cookie Атрибуты (их упрощает функция setcookie)</p>
<ul>
<li>Ключ и значение</li>
<li>Срок действия</li>
</ul>
<p>Если нет – до закрытия браузера!</p>
<p>Формат 'r' (RFC 2822), GMT</p>
<ul>
<li>Путь</li>
<li>Домен</li>
</ul>
<p><strong>Автоматически доступны и для поддоменов</strong></p>
<p>Признак HTTPS (запрет на передачу от клиента по незашифрованному соединению)</p>
<p>HTTPOnly Недоступность через JavaScript</p>
<code>
Set-Cookie: foo=bar; expires=Fri, 31</br>
Dec 2010 23:59:59 GMT; path=/;</br>
domain=.example.net</br>
</code>
<p>setcookie('имя куки', 'значение'); // без указания времени (время указывается в формате Unix time) это сессионная кука, до закрытия браузера</p>
<code>
echo time() + 60*60 — функция возвращает текущее время в формате Unix time
</code>
<p>или</p>
<code>
echo time() + 3600 - выставлние времени на час
</code>
<p>итог примера:</p>
<code>
setcookie('имя куки', 'значение', time() + 60*60);
</code>
<p>Читать $_COOKIE — php берет содержимое заголовка cookie который передан от клиента</p>
<p>При изменении cookie в запросе в ответе придет просьба изменить, при втором запросе браузер передаст изменившуюся cookies</p>
<p>Цель cookie просто пометить пользователя, не более.</p>
<p>setcookie() — Для установки cookie (передачи заголовка клиенту) используйте функцию</p>
<ul>
<li>$name</li>
<li>$value</li>
<li>$expired</li>
<li>$path</li>
<li>$domain</li>
<li>$secure</li>
<li>$httponly</li>
</ul>
<p>Для чтения cookie (переданных от клиента!) используйте суперглобальный массив $_COOKIE</p>
<p>Внимание: только читать! Запись в него не имеет смысла</p>
</br>

<h3>Сессии</h3>
<p>Допустим, мы «пометили» клиента с помощью cookie. А что дальше? Как сохранить какие-то данные безопасно?</p>
<p><strong>Сессии</strong> – встроенный в PHP способ хранения данных на сервере между последовательными запросами одного и того же клиента:</p>
<ul>
<li>Уникальный идентификатор сессии</li>
<li>Выбор способа передачи идентификатора (cookie или get-параметр)</li>
<li>Выбор хранилища данных сессий</li>
<li>Удобный интерфейс для доступа к данными: массив $_SESSION</li>
</ul>
<p>Полезные функции:</p>
<p><strong>session_start();</strong> — с этой функции начинаем скрипты в которых предполагается использование сессии</p>
<p><strong>session_id();</strong></p>
<p><strong>session_regenerate_id();</strong> - забываем клиента и он как бы новым становится.</p>
<p>Пример 1 страница: $_SESSION['foo'] = 24; - массив действует и на чтение и на запись</p>
<p>Пример 2 страница: session_start();</p>
<code>
var_dump($_SESSION); //спрашиваем что у нас тут в сессии хранилось, так можно связать пользователя по всем страницам как понимаю
</code>
<p>Пример как следить за пользователем (счетчик посещений):</p>
<p>страница test1</p>
<code>
session_start(); // именно с этого момента данные будут хранится на сервере, но они будут</br> 
$_SESSION['pages'][] = 'test1'; - добавляем в массив имя последней посещенной страницы</br>
var_dump($_SESSION);</br>
</code> 
<p>страница test2</p>
<code>
session_start();</br>
$_SESSION['pages'][] = 'test2'; - добавляем в массив имя последней посещенной страницы</br>
var_dump($_SESSION);</br>
</code>
<p>страница test3</p>
<code>
session_start();</br>
$_SESSION['pages'][] = 'test3'; - добавляем в массив имя последней посещенной страницы</br>
var_dump($_SESSION);</br>
</code>
</br>

<h3>Хэш-функции</h3>
<p><strong>Хэш-функции</strong> — Это «односторонние функции», позволяющие по тексту произвольной длины получить некий короткий, достаточно случайный «хэш»-идентификатор текста.</p>
<p>Самый простой (и совершенно дурацкий) пример – функция вычисления длины текста // алгоритм плохой</p>
<p>Современные алгоритмы:</p>
<ul>    
<li>md5 (категорически устарел)</li>
<li>sha1 (устарел)</li>
</ul>
<p>Пример:</p>
<code>
echo sha1('123456'); - вернет хер ранее применяемый для шифрования, его можно хранить в базе данных, вместо пароля, так как пароль в чистом виде нельзя хранить</br>
$db == sha1($_POST('123456'); - далее стравниваем то что хранится в базе данных и то что вел пользователь</br>
</code>
<ul>
<li>sha256, sha512</li>
<li>gost-crypto</li>
</ul>
<p><strong>Для чего нам может пригодиться хэшфункция?</strong></p>
<ul>
<li>«Свёртка» длинных значений в короткие</li>
<li>Получение псевдослучайной строки (используем время, /dev/urandom, соль)</li>
<li>Одностороннее шифрование</li>
</ul>
<p>Как же правильно <strong>хэшировать пароли</strong>? Хэширование часто применяется для одностороннего шифрования пароля:</p>
<ul>
<li>Храним в базе пользователей не пароли, а хэши паролей</li>
<li>Когда пользователь вводит пароль в форму входа – снова вычисляем хэш</li>
<li>Если вычисленный и сохранённый хэши совпали – считаем проверку пароля пройденной</li>
</ul>
<p>В PHP следует ВСЕГДА использовать встроенные функции</p>
<ul>
<li>password_hash()</li>
<li>password_verify()</li>
</ul>
<p>- они обеспечивают максимально безопасное хэширование и проверку хэша!</p>
<p>index</p>
<form action="/send.php" method="post">
<input type="text" name="login">
<input type="password" name="pass">
<button type="submit">Войти</button>
<p>send</p>
<code>
echo password_hash('123456', PASSWORD_DEFAULT); // PASSWORD_DEFAULT - означает возьми самый сильный алгоритм который тебе сейчас доступен
эметируем базу данных:</br>
$users = [</br>
    'Vasya' => 'вставляем хэш из password_hash'</br>
];</br>
if(isset($users[$_POST['login']])) { // если существует в юзерс элемент с ключем соответсвующим логину</br>
    echo 'пользователь найден';</br>
    if(password_verify($_POST['password'], $users[$_POST['login']])) { // передаем то что ввел юзер в пароль и тот хеш который мы храним</br>
    echo 'добро пожаловать';</br>
    } else {</br>
       echo 'пароль не подошел';</br>
    }</br>
}</br>
</code>
<p><strong>Индификация</strong> — это то, как клиент представляется (ввод логин прароль).</p>
<p><strong>Аунтификация</strong> — мы проверили что клиент не врет (проверка логин пароль).</p>
<p><strong>Авторизация</strong> — доступ к ресурсу (доступ на сервис).</p>
</form>
</body>
</html>